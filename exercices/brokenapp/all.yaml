---
kind: BuildConfig
apiVersion: build.openshift.io/v1
metadata:
  name: "my-app-buildconfig"
  namespace: myapp
spec:
  runPolicy: "Serial"
  triggers:
    - type: "ImageChange"
    #- type: "ConfigChange"
  source:
    configMaps:
      - configMap:
          name: my-python-source
    dockerfile: |
      FROM python:3.9.1-alpine
      RUN apk update && apk add curl wget vim tar bash less
      COPY myscript.py /myapp/myscript.py
      COPY requirements.txt /myapp/requirements.txt
      #RUN chgrp -R 0 /myapp && chmod -R g=u /myapp
      RUN python -m pip install -r /myapp/requirements.txt
      ENV FLASK_APP /myapp/myscript.py
      ENV FLASK_RUN_PORT 8080
      ENV FLASK_RUN_HOST 127.0.0.1
      CMD ["python", "-m", "flask", "run"]
  strategy:
    dockerStrategy:
      #noCache: true
      from:
        kind: "DockerImage"
        name: "python:3.9.1-alpine"
  output:
    to:
      kind: "ImageStreamTag"
      name: "my-app-image:latest"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-configmap-html
  namespace: myapp2
data:
  index.html: |
    This is my personalised index.html
  configmap.html: |
    This is my ConfigMap page !
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: python-source
  namespace: myapp
data:
  myscript.py: |
    from flask import Flask
    app = Flask(__name__, static_url_path='/myapp', static_folder='/myapp')

    @app.route('/')
    def hello_world():
      return 'Hello, World!'
    @app.route('/health')
    def readiness_probe():
      return 'Ready', 200
    @app.route('/live')
    def liveness_probe():
      return 'Forbidden liveness', 503

  requirements.txt: |
    Flask
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  namespace: myapp
  annotations:
    image.openshift.io/triggers: '[{"from":{"kind":"ImageStreamTag","name":"my-app-image:latest"},"fieldPath":"spec.template.spec.containers[?(@.name==\"my-app-imagestream\")].image"}]'
spec:
  selector:
    matchLabels:
      app: myapp
  replicas: 1
  template:
    metadata:
      labels:
        app: myapp
        version: "1"
      annotations:
        sidecar.istio.io/inject: "true"
    spec:
      containers:
        - name: myapp
          image: my-app-imagestream:latest
          imagePullPolicy: "Always"
          ports:
            - containerPort: 8080
          resources:
            requests:
              cpu: 10
              memory: "5Gi"
            limits:
              cpu: 0.1
              memory: "100Gi"
          readinessProbe:
            httpGet:
              path: "/healthy"
              port: 80
            initialDelaySeconds: 3
            periodSeconds: 3
            failureThreshold: 1
            timeoutSeconds: 1
          livenessProbe:
            httpGet:
              path: "/live"
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 3
            failureThreshold: 1
            timeoutSeconds: 1
          volumeMounts:
            - name: my-configmap-html-volume
              mountPath: "/myapp/html/"
              readOnly: true
            - name: my-secret-page-volume
              mountPath: "/myapp/secret/"
              readOnly: true
            - name: my-app-pvc-volume
              mountPath: "/myapp/pvc/"
              readOnly: false
      serviceAccountName: myapp-sa
      securityContext:
        runAsUser: 1000
      volumes:
        - name: my-configmap-html-volume
          configMap:
            name: my-configmap-html
        - name: my-secret-page-volume
          secret:
            secretName: my-secret-html
        - name: my-app-pvc-volume
          persistentVolumeClaim:
            claimName: my-app-pvc

---
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: my-app-gateway
  namespace: myapp
spec:
  selector:
    istio: ingressgateway # use istio default controller
  servers:
  - port:
      number: 5000
      name: http-flask
      protocol: HTTP
    hosts:
    - my-app-gateway.apps-crc.testing
---
apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  name: my-app-image
  namespace: myapp
  annotations:
    openshift.io/display-name: my-app-is
spec:
  lookupPolicy:
    local: false
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
  namespace: myapp
  annotations:
    #nginx.ingress.kubernetes.io/rewrite-target: /
    haproxy.router.openshift.io/rewrite-target: /
spec:
  rules:
  - host: my-app-ingress.apps-crc.testing
    http:
      paths:
        - path: /myapp
          pathType: Prefix
          backend:
            service:
              name: my-app-svc
              port:
                #number: 80
                name: http-port
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-app-pvc
  namespace: myapp
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  #storageClassName: my-local-storageclass
  storageClassName: ""
  resources:
    requests:
      storage: 10Mi
---
apiVersion: v1
kind: Project
metadata:
  name: myapp
---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: my-app-limits
  namespace: myapp
spec:
  hard:
    requests.cpu: "0.001"
    persistentvolumeclaims: "1"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: my-scc-user-rolebinding
  namespace: myapp
subjects:
  - kind: ServiceAccount
    name: myapp-svc
    apiGroup: ""
roleRef:
  kind: Role
  name: my-scc-user-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: Secret
metadata:
  name: my-secret-html
  namespace: myapp
type: Opaque
data:
  secret.html: "My Secret Page"
---
apiVersion: v1
kind: Service
metadata:
  name: my-app-svc
  namespace: myapp
spec:
  selector:
    app: myapp
  ports:
    - name: http-flask
      protocol: TCP
      port: 80
      targetPort: 5000
---
apiVersion: v1
#imagePullSecrets:
#- name: my-docker-pull-secret
kind: ServiceAccount
metadata:
  name: myapp-sa
  namespace: myapp
automountServiceAccountToken: false
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: my-app-virtualservice
  namespace: myapp
spec:
  hosts:
  - my-app-gateway.apps-crc.testing
  gateways:
  - myapp/my-app-gateway
  - mesh # applies to all the sidecars in the mesh
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: my-app
        port:
          number: 8080

---
